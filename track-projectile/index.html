<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>three.js dev</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>
		<script src="../assets/js/three.min.js"></script>
		<script src="../assets/js/controls/OrbitControls.js"></script>
		<script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            var controls = new THREE.OrbitControls(camera);
            //controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2 - 0.01

			// Initialize the renderer
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            document.body.style.overflow = 'hidden';

			// Initialize the rocket Group
			const rocket = new THREE.Group();

			// Nose cone
			let points = [];
			for (let i = 0; i < 0.5; i += 0.01) {
				points.push(new THREE.Vector2(10.2*i, 10*Math.sqrt(12 * (1 - Math.pow(i+0.5, 2)))));
			}
			const noseGeometry = new THREE.LatheGeometry(points, 64);
			const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000, side: THREE.DoubleSide });
			const noseLathe = new THREE.Mesh(noseGeometry, noseMaterial);
			noseLathe.position.y = 95
			rocket.add(noseLathe);

			// Body Cylinder
			const bodyGeometry = new THREE.CylinderGeometry(5, 5, 100, 64);
			const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, side: THREE.DoubleSide });
			const bodyCylinder = new THREE.Mesh(bodyGeometry, bodyMaterial);
			bodyCylinder.position.y = 50
			rocket.add(bodyCylinder);

			// Fins
			const numFins = 4
			const spacing = 2 * Math.PI/numFins
			const center = new THREE.Vector3(0, 0, 0)
			const finHeight = 5
			const finBaseLength = 20
			const finTopLength = 5
			const finDistFromCenter = 5
			const fins = new THREE.Group();
			for (let finNum = 0; finNum < numFins; finNum++) {
				const angle = spacing * finNum
				const finMaterial = new THREE.MeshPhongMaterial({ color: 0x0000FF, side: THREE.DoubleSide });
				const finGeometry = new THREE.Geometry();
				finGeometry.vertices = [
					new THREE.Vector3(center.x+finDistFromCenter*Math.cos(angle),center.y,center.z+finDistFromCenter*Math.sin(angle)),
					new THREE.Vector3(center.x+finDistFromCenter*Math.cos(angle),center.y+finBaseLength,center.z+finDistFromCenter*Math.sin(angle)),
					new THREE.Vector3(center.x+(finDistFromCenter+finHeight)*Math.cos(angle),center.y+finTopLength,center.z+(finDistFromCenter+finHeight)*Math.sin(angle)),
					new THREE.Vector3(center.x+(finDistFromCenter+finHeight)*Math.cos(angle),center.y,center.z+(finDistFromCenter+finHeight)*Math.sin(angle))
				];
				finGeometry.faces = [
					new THREE.Face3(0,1,3),
					new THREE.Face3(1,2,3)
				];
				const finMesh = new THREE.Mesh(finGeometry, finMaterial);
				fins.add(finMesh);
			}
			rocket.add(fins)

			scene.add(rocket)

			// Create a point light and an ambient light
            const pointLight1 = new THREE.PointLight(0xFFFFFF);
            pointLight1.position.x = 300;
            pointLight1.position.y = 1000;
            pointLight1.position.z = 400;
            scene.add(pointLight1);
            const light = new THREE.AmbientLight(0x555555);
			scene.add(light);

			// Create a ground plane
            var geometry = new THREE.PlaneGeometry(2000, 2000);
            var material = new THREE.MeshBasicMaterial({color: 0x003300, side: THREE.DoubleSide});
            var plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = Math.PI / 2
            plane.position.z = 0
            scene.add(plane);

            camera.position.set(0, 100, 100);
            camera.rotation.y = 0.0;
            controls.update();

			var lastTimestamp = performance.now()
            requestAnimationFrame(animate);

			// Add handler for window resize
            const tanFOV = Math.tan(((Math.PI / 180) * camera.fov / 2));
            const initialWindowHeight = window.innerHeight;
            window.addEventListener('resize', onWindowResize, false);

            function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
                camera.fov = (360 / Math.PI) * Math.atan(tanFOV * (window.innerHeight / initialWindowHeight));
                camera.updateProjectionMatrix();
                camera.lookAt(scene.position);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.render(scene, camera);
			}

			// Main update function
            function animate(timestamp) {
				const dx = timestamp - lastTimestamp // in ms
				const frameRate = 1000/dx // in FPS/Hz
				lastTimestamp = timestamp
                controls.update()
            	renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
		</script>
	</body>
</html>
